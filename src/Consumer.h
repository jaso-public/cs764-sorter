#pragma once

#include <memory>

#include "Provider.h"
#include "Record.h"
#include "IODevice.h"

using namespace std;

/**
 * This is the Consumer class that will be utilized to consume the records generated by the Provider class
 * It contains one virtual method, consume(), that all other Consumers must implement.
 */
class Consumer {
public:
    virtual ~Consumer() {}

    /**
     * The virtual method that all other consumers have to implement
     * It continues to consume records from a provider until there are not records left
     */
    virtual void consume() = 0;
};

/**
 * This class continuously calls the given provider's next() method until all records have been returned
 * It is utilized for testing purposes
 */
class NoopConsumer : public Consumer {
public:
    /**
     * Class constructor that sets the given provider
     * @param _source the provider to obtain records from
     */
    NoopConsumer(shared_ptr<Provider> _source): source(_source) {}

    /**
     * Continues to call the providers next method until a null pointer has been reached
     */
    void consume() override {
        while(true) {
            shared_ptr<Record> ptr = source->next();
            if(ptr == nullptr) return;
        }
    }

private:
    shared_ptr<Provider> source; // the source that will generate records
};


/**
 * This class will write records obtained from the given provider to a file
 * It is utilized to write the sorted record to the output file
 */
class DeviceConsumer : public Consumer {
public:
    /**
    * Class constructor that initializes class variables and creates a buffer of the desired size
    * @param _source the provider to obtain records from
    * @param _device IO device that will write to the output file
    * @param _bufferSize the size of the buffer to store records in
    */
    DeviceConsumer(shared_ptr<Provider> _source, shared_ptr<IODevice> _device, int _bufferSize);
    /**
    * Continues to obtain records from the provider and passes them to the appendRecord() function
    * Flushes the record data once all records have been consumed
    */
    void consume() override;

private:
    /**
     * This method will write the buffer's contents to the file within the IO device
     * It will then reset the buffer offset, so it can store more records
     */
    void doWrite();
    /**
     * This method will continue to store records into the buffer until the buffer is full
     * Once the buffer is full, it will call doWrite() to write the buffer contents to the particular file
     * @param ptr the next record to write to the buffer
    */
    void appendRecord(shared_ptr<Record> &ptr);
    shared_ptr<Provider> source;                   // the source that will generate records
    shared_ptr<IODevice> outputDevice;             // the output device where the records will be written
    uint64_t deviceOffset;                         // the location where the next buffer should be written
    unique_ptr<uint8_t[]> buffer;                  // a smallish buffer to stage data so we don,t make so many os calls
    int bufferSize;                                // the size of the buffer
    int bufferOffset;                              // the offset into the buffer which has already been filled
 };
