#include <unistd.h>  // for getopts
#include <iostream>
#include <system_error>
#include <charconv>
#include <cstdint>
#include <cstring>
#include <type_traits> // For std::is_integral

#include "Provider.h"
#include "IODevice.h"
#include "Consumer.h"

// generated by my good friend, ChatGpt
template<typename IntegerType, typename std::enable_if<std::is_integral<IntegerType>::value, bool>::type = true>
bool parseInteger(const char* str, IntegerType& outValue) {
    std::from_chars_result result = std::from_chars(str, str + std::strlen(str), outValue);

    if (result.ec == std::errc::invalid_argument) {
        std::cerr << "Error: Invalid argument." << std::endl;
        return false;
    } else if (result.ec == std::errc::result_out_of_range) {
        std::cerr << "Error: Result out of range." << std::endl;
        return false;
    } else if (result.ptr != str + std::strlen(str)) {
        // Not all characters were consumed, indicating some invalid input.
        std::cerr << "Error: Entire string not converted." << std::endl;
        return false;
    }

    // Success
    return true;
}

template<typename T>
bool parseFloatingPoint(const std::string& str, T& value) {
    static_assert(std::is_floating_point<T>::value, "T must be a floating point type");

    std::istringstream iss(str);
    iss >> value;

    // Check if the entire string was consumed and if the read was successful
    return iss.eof() && !iss.fail();
}

void usage(const char* programName, const char* message) {
    std::cout << "Error: " << message << std::endl;
    std::cout << "usage: " << programName << " [options]" << std::endl;
    std::cout << "       -f<filename>    name of the output file to generate." << std::endl;
    std::cout << "       -c<recordCount> number of records to generate." << std::endl;
    std::cout << "       -s<recordSize>  size of the records to generate. " << std::endl;
    std::cout << "       -p<probabilty>  probability of generating an alternate key " << std::endl;
    std::cout << "       -r<range>       possible range of values for the alternate key. " << std::endl;
    std::cout << "       -n              make the last byte of the record a new line." << std::endl;
    std::cout << std::endl;
    std::cout << "This generator creates records from the character set A-Z, a-z, 0-9.  Normally," << std::endl;
    std::cout << "it just generates random strings using this character set.  You can also" << std::endl;
    std::cout << "request that a newline character is added to the end of the record, this is handy" << std::endl;
    std::cout << "if you want to examine the records in vi or use unix command line tools to analyze the file." << std::endl;
    std::cout << std::endl;
    std::cout << "Although the generator makes random keys, the likelihood of getting duplicate keys" << std::endl;
    std::cout << "is very low (depending on your key length).  For some test loads, you may want the " << std::endl;
    std::cout << "generated file to contain duplicate keys with a much higher probability.  To do this" << std::endl;
    std::cout << "you can specify the probability (-p) and range (-r) for the generator.  The probablity" << std::endl;
    std::cout << "is the liklihood that the next key generated will be created in the range specified.  " << std::endl;
    std::cout << "For example if you specify a probability of 0.1 and a range of 100 (-p 0.1 -r 100) then" << std::endl;
    std::cout << "1/10 of the records generated on average will have keys in the range [0,100].  If you" << std::endl;
    std::cout << "were to genereate one million records, then about 100,000 of them would have keys in the" << std::endl;
    std::cout << "range.  Therefore you should expect on average that there 1000 duplicate keys for each of" << std::endl;
    std::cout << "the specially generated keys." << std::endl;
    std::cout << std::endl;

    exit(1);
}

int main (int argc, char * argv []) {

    std::string fileName = "input.txt";
    uint64_t recordCount = 1000;
    uint32_t recordSize = 128;
    double_t probability = 0;
    uint64_t range = 100;
    bool newLine = false;

    int opt;
    while ((opt = getopt(argc, argv, "f:c:s:p:r:nh")) != -1) {
        switch (opt) {
            case 'h':
                usage(argv[0], "This help message.");
                break;
            case 'f':
                fileName = optarg;
                break;
            case 'n':
                newLine = true;
                break;
            case 'c':
                if(! parseInteger(optarg, recordCount)) {
                    usage(argv[0], "unable to parse record count");
                }
                break;
            case 's':
                if(! parseInteger(optarg, recordSize)) {
                    usage(argv[0], "unable to parse record size");
                }
                break;
            case 'p':
                if(! parseFloatingPoint(optarg, probability)) {
                    usage(argv[0], "unable to parse probability for duplicates");
                }
                break;
            case 'r':
                if(! parseInteger(optarg, range)) {
                    usage(argv[0], "unable to parse range of the duplicate keys");
                }
                break;
            case '?':
                if (optopt == 'f')
                    std::cerr << "Option -" << char(optopt) << " requires an argument.\n";
                else
                    std::cerr << "Unknown option: -" << char(optopt) << '\n';
                return 1;
            default: // Should not get here
                break;
        }
    }

    std::cout << "outputFile: " << fileName << std::endl;
    std::cout << "record count: " << recordCount << std::endl;
    std::cout << "record size: " << recordSize << std::endl;
    std::cout << "probability: " << probability << std::endl;
    std::cout << "range: " << range << std::endl;
    std::cout << "new line: " << newLine << std::endl;


    auto provider = make_shared<DuplicateProvider>(recordCount, probability, range, newLine);
    auto device = make_shared<IODevice>(fileName);
    auto consumer = make_shared<DeviceConsumer>(provider, device, 256*1024);
    consumer->consume();

    device->writeStats();
    return 0;
}
