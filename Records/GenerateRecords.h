#ifndef CS764_SORTER_GENERATERECORDS_H
#define CS764_SORTER_GENERATERECORDS_H
#include <unistd.h>

#include <iostream>
#include <system_error>
#include <charconv>
#include <cstdio>
#include <cstdint>
#include <cstring>
#include <random>
#include <sstream> // For std::istringstream
#include <type_traits> // For std::is_integral

// generated by my good friend, ChatGpt
template<typename IntegerType, typename std::enable_if<std::is_integral<IntegerType>::value, bool>::type = true>
bool parseInteger(const char* str, IntegerType& outValue) {
    std::from_chars_result result = std::from_chars(str, str + std::strlen(str), outValue);

    if (result.ec == std::errc::invalid_argument) {
        std::cerr << "Error: Invalid argument." << std::endl;
        return false;
    } else if (result.ec == std::errc::result_out_of_range) {
        std::cerr << "Error: Result out of range." << std::endl;
        return false;
    } else if (result.ptr != str + std::strlen(str)) {
        // Not all characters were consumed, indicating some invalid input.
        std::cerr << "Error: Entire string not converted." << std::endl;
        return false;
    }

    // Success
    return true;
}

template<typename T>
bool parseFloatingPoint(const std::string& str, T& value) {
    static_assert(std::is_floating_point<T>::value, "T must be a floating point type");

    std::istringstream iss(str);
    iss >> value;

    // Check if the entire string was consumed and if the read was successful
    return iss.eof() && !iss.fail();
}

void usage(const char* programName, const char* message) {
    std::cout << "Error: " << message << std::endl;
    std::cout << "usage: " << programName << " [options]" << std::endl;
    std::cout << "       -f<filename>    name of the output file to generate." << std::endl;
    std::cout << "       -f-             writes the output to stdout." << std::endl;
    std::cout << "       -c<recordCount> number of records to generate." << std::endl;
    std::cout << "       -s<recordSize>  size of the records to generate. " << std::endl;
    std::cout << "       -k<keyOffset>   offset into the record where the key begins. " << std::endl;
    std::cout << "       -l<keyLength>   length of the key" << std::endl;
    std::cout << "       -p<probabilty>  probability of generating an alternate key " << std::endl;
    std::cout << "       -r<range>       possible range of values for the alternate key. " << std::endl;
    std::cout << "       -n              make the last byte of the record a new line." << std::endl;
    std::cout << "       -q              quiet, do not print the argument values." << std::endl;
    std::cout << std::endl;
    std::cout << "This generator creates records from the character set A-Z, a-z, 0-9.  Normally," << std::endl;
    std::cout << "it just generates random strings using this character set.  You can also" << std::endl;
    std::cout << "request that a newline character is added to the end of the record, this is handy" << std::endl;
    std::cout << "if you want to examine the records in vi or use unix command line tools to analyze the file." << std::endl;
    std::cout << std::endl;
    std::cout << "Although the generator makes random keys, the likelihood of getting duplicate keys" << std::endl;
    std::cout << "is very low (depending on your key length).  For some test loads, you may want the " << std::endl;
    std::cout << "generated file to contain duplicate keys with a much higher probability.  To do this" << std::endl;
    std::cout << "you can specify the probability (-p) and range (-r) for the generator.  The probablity" << std::endl;
    std::cout << "is the liklihood that the next key generated will be created in the range specified.  " << std::endl;
    std::cout << "For example if you specify a probability of 0.1 and a range of 100 (-p 0.1 -r 100) then" << std::endl;
    std::cout << "1/10 of the records generated on average will have keys in the range [0,100].  If you" << std::endl;
    std::cout << "were to genereate one million records, then about 100,000 of them would have keys in the" << std::endl;
    std::cout << "range.  Therefore you should expect on average that there 1000 duplicate keys for each of" << std::endl;
    std::cout << "the specially generated keys." << std::endl;
    std::cout << std::endl;
    std::cout << "Below are the counts of the duplicate keys generated:" << std::endl;
    std::cout << "./generateRecords -c 1000000 -n -p0.1 -r 100 -k0 -f- |  cut -c1-8 | grep -v \"[a-z]\" | grep -v \"[A-Z]\" | sort | uniq -c" << std::endl;
    std::cout << "957 00000000" << std::endl;
    std::cout << "990 00000001" << std::endl;
    std::cout << "998 00000002" << std::endl;
    std::cout << "1017 00000003" << std::endl;
    std::cout << "1017 00000004" << std::endl;
    std::cout << "990 00000005" << std::endl;
    std::cout << "970 00000006" << std::endl;
    std::cout << "996 00000007" << std::endl;
    std::cout << "993 00000008" << std::endl;
    std::cout << "983 00000009" << std::endl;
    std::cout << "984 00000010" << std::endl;
    std::cout << "992 00000011" << std::endl;
    std::cout << "987 00000012" << std::endl;
    std::cout << "996 00000013 ..." << std::endl;


    exit(1);
}

int main3 (int argc, char * argv []) {

    std::string fileName = "input.txt";
    uint64_t recordCount = 1000;
    uint32_t recordSize = 128;
    uint32_t keyOffset = 8;
    uint32_t keyLength = 8;
    double_t probability = 0;
    uint64_t range = 100;
    bool newLine = false;
    bool quiet = false;

    int opt;
    while ((opt = getopt(argc, argv, "f:c:s:k:l:p:r:nqh")) != -1) {
        switch (opt) {
            case 'h':
                usage(argv[0], "This help message.");
                break;
            case 'f':
                fileName = optarg;
                break;
            case 'n':
                newLine = true;
                break;
            case 'q':
                quiet = true;
                break;
            case 'c':
                if(! parseInteger(optarg, recordCount)) {
                    usage(argv[0], "unable to parse record count");
                }
                break;
            case 's':
                if(! parseInteger(optarg, recordSize)) {
                    usage(argv[0], "unable to parse record size");
                }
                break;
            case 'k':
                if(! parseInteger(optarg, keyOffset)) {
                    usage(argv[0], "unable to parse key offset");
                }
                break;
            case 'l':
                if(! parseInteger(optarg, keyLength)) {
                    usage(argv[0], "unable to parse key offset");
                }
                break;
            case 'p':
                if(! parseFloatingPoint(optarg, probability)) {
                    usage(argv[0], "unable to parse probability for duplicates");
                }
                break;
            case 'r':
                if(! parseInteger(optarg, range)) {
                    usage(argv[0], "unable to parse range of the duplicate keys");
                }
                break;
            case '?':
                if (optopt == 'f')
                    std::cerr << "Option -" << char(optopt) << " requires an argument.\n";
                else
                    std::cerr << "Unknown option: -" << char(optopt) << '\n';
                return 1;
            default: // Should not get here
                break;
        }
    }

    if( !quiet) {
        std::cout << "outputFile: " << fileName << std::endl;
        std::cout << "record count: " << recordCount << std::endl;
        std::cout << "record size: " << recordSize << std::endl;
        std::cout << "key offset: " << keyOffset << std::endl;
        std::cout << "key length: " << keyLength << std::endl;
        std::cout << "probability: " << probability << std::endl;
        std::cout << "range: " << range << std::endl;
        std::cout << "new line: " << newLine << std::endl;
    }

    uint32_t limit = recordSize;
    if(newLine) limit--;
    if(limit < keyOffset + keyLength) {
        usage(argv[0], "key not is within the record size");
    }

    std::random_device rd; // Obtain a seed from the system entropy device, or use a fixed seed for reproducible results
    std::mt19937 gen(rd()); // Seed the generator

    std::uniform_int_distribution<> distrib(0, 61); // used to get the random characters
    std::uniform_real_distribution<> randomProbabilty(0.0, 1.0); // used to determine if should change the key
    std::uniform_int_distribution<> randomRange(0, range); // if we are changing the key, this chooses the value

    // Define a custom deleter that does nothing
    auto noop_deleter = [](std::ostream*) {};

    // Use std::unique_ptr with a custom deleter that does nothing
    std::unique_ptr<std::ostream, decltype(noop_deleter)> stream(nullptr, noop_deleter);

    std::ofstream outFile;

    if (fileName != "-") {
        outFile.open(fileName);
        if (!outFile) {
            std::cerr << "Failed to open file: " << fileName << std::endl;
            return 1;
        }
        stream.reset(&outFile);
    } else {
        stream.reset(&std::cout); // Using a custom deleter that does nothing
    }

    char* buffer = new char[recordSize];
    char* temp = new char[keyLength+1];

    for(uint64_t n=0 ; n<recordCount ; n++) {
        for(int i=0 ; i<recordSize ; i++) {
            uint8_t value = distrib(gen);
            if (value < 26) {
                buffer[i] = value + 'A';
            } else if (value < 52) {
                buffer[i] = value - 26 + 'a';
            } else {
                buffer[i] = value - 52 + '0';
            }
        }

        if(randomProbabilty(gen) < probability) {
            uint64_t value = randomRange(gen);
            snprintf(temp, keyLength+1, "%0*llu", keyLength, value);
            memcpy(buffer + keyOffset, temp, keyLength);
        }

        if(newLine) {
            buffer[recordSize-1] = '\n';
        }

        stream->write(buffer, recordSize);
    }

    if(fileName != "-") {
        outFile.close();
    }

    return 0;
} // main

#endif //CS764_SORTER_GENERATERECORDS_H
